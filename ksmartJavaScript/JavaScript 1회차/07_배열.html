<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" href="#" type="image/x-icon">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
</head>
<body>
   <h1>배열</h1>
	- 하나의 저장소를 분할하여 데이터를 저장하는 객체 <br>
	- 나눠진 데이터의 저장소의 주소는 index라고 한다. <br>
	- index는 0부터 시작된다. <br>
	- 배열 객체에 담긴 대상을 요소(원소) 라고 한다.
	<script type="text/javascript">
		// 배열생성
		const arr = [];
		console.log(arr);
		const arr2 = new Array();
		console.log(arr2);

		//배열 생성하면 원소 초기화
		const arr3 = ['홍길동','김철수'];
		console.log(arr3);
		const arr4 = new Array('홍길동','김철수');
		console.log(arr4);

		//숫자 하나일 경우
		const arr5 = [2];
		console.log(arr5);
		const arr6 = new Array(2);
		console.log(arr6);

		// Javascript는 타입이 정해진 언어가 아니기 때문에 모든 데이터를 할당할 수 있다.
		const arr7 = [1,'가',true,null,undefined, {},[],function(){}];
		console.log(arr7);

	</script>
	
	<h2>배열에 값 대입 및 접근</h2>
	- 배열의 인덱스로 배열의 값에 접근 혹은 대입이 가능하다.
	
	<script type="text/javascript">
		// call by value(값) vs call by referense(주소)
		const num1 = 100;
		const num2 = 100;
		// 값을 호출하기 때문에 비교가능
		console.log(num1 == num2,'<--call by value');
		const compareArr1 = [100]; // 배열을 생성한 메모리 주소값이 할당
		const compareArr2 = [100]; // 배열을 생성한 메모리 주소값이 할당
		//단순하게 비교할 수 없다.
		console.log(compareArr1 == compareArr2,'<--call by reference');
		// 배열[index]
		console.log(compareArr1[0] == compareArr2[0]);
		// 배열의 요소 재할당
		compareArr1[0] = 200;
		console.log(compareArr2.length);
		const length = compareArr2.length;
		compareArr2[length]=200;
		console.log(compareArr2);
		
		
	</script>
	
	<h2>배열객체의 속성 및 메서드</h2>
	(객체에는 속성과 메서드가 있다.) <br>
	- length : 배열의 크기를 알수 있는 속성 <br>
	- push() : 배열에 값을 삽입하는 메서드 <br>	
	- pop() : 배열의 마지막 요소 제거 후 제거된 요소 반환<br>
	- unshift() : 배열의 처음 요소로 값을 삽입하는 메소드<br>
	- shift() : 배열의 처음 요소 제거 후 제거된 요소 반환<br>
	- splice(삭제를 시작할 인덱스, 삭제할 요소수) : 특정배열 요소 삭제 <br>
	- Array.isArray(배열 변수명) : 배열 여부 확인<br>	
	<script type="text/javascript">
		const targetArray = [100,200,300,400];
		console.log(targetArray.length,'<-- 배열의 크기를 가진 속성');
		
		//push(): 변경된 배열의 크기를 반환
		let pushReturn = targetArray.push(500,600); 
		console.log(targetArray);
		console.log(pushReturn);

		//pop(): 배열에서 제거된 마지막요소를 반환
		let popReturn = targetArray.pop();
		console.log(targetArray);
		console.log(popReturn);
		
		//unshift() : 변경된 배열의 크기를 반환
		let unshiftReturn = targetArray.unshift(10,20,30);
		console.log(targetArray);
		console.log(unshiftReturn);

		//shift() : 배열에서 제거된 첫번째 요소를 반환
		let shiftReturn = targetArray.shift();
		console.log(targetArray);
		console.log(shiftReturn);

		//splice() : 배열의 요소를 제거, 추가
		//splice(삭제를 시작할 인덱스,인덱스로부터 몇개를 삭제 숫자)
		//삭제된 요소를 새로운 배열에 담아서 반환
		let spliceReturn = targetArray.splice(2,3);
		console.log(targetArray);
		console.log(spliceReturn);
		console.log(Array.isArray(spliceReturn)); 

		//splice(추가시킬 인덱스, 0, 추가할 데이터);
		spliceReturn = targetArray.splice(2,0,40,50);
		console.log(targetArray);
		console.log(spliceReturn);

	</script>

	<h2>얕은복사 vs 깊은복사</h2>
	- 얕은복사: 새로운 복합 객체를 만들고,(가능한 범위까지) 원본 객체를 가리키는 참조를 새로운 복합 객체에 삽입<br>
						복사 후 같은 주소를 참조 (인스턴스 생성 x)<br>
						'주소 값'을 복사한다는 의미<br>
	- 깊은복사: 새로운 복합 객체를 만들고, 재귀적으로 원본 객체의 사본을 새로 만든 복합 객체에 삽입<br>
						복사 후 다른 주소를 참조 (인스턴스 생성 o)<br>
						'실제 값'을 새로운 메모리 공간에 복사하는 것을 의미<br>
	<script type="text/javascript">
		console.log(`=======얕은복사 vs 깊은복사=========`)
		let num = 100;
		let copyNum = num;
		num = 200;
		console.log(num);
		console.log(copyNum);
		console.log(num == copyNum);
		// 생성된 객체의 주소값이 변수에 할당
		const exArr = [100,200]; // 참조데이터타입 : 객체
		const copyArr = exArr; // 주소값을복사 : 얕은복사
		copyArr[1] = 300;
		console.log(exArr);
		console.log(copyArr);
		console.log(exArr == copyArr);

		//깊은복사 새로운 배열객체를 생성해서 for문을 통해 값을 복사
		const exArr2 = [100,200,[300]];
		const deepCopyArr = [];
		console.log('여기봐야함');
		for(const element of exArr2){
			deepCopyArr.push(element);
		}
		deepCopyArr[1]=300;
		console.log(exArr2);
		console.log(deepCopyArr);


	</script>
</body>
</html>